#' Count the number of UMIs for each gene and output expression matrix
#' 
#' Count unique \emph{UMI:gene} pairs for single cell RNA-sequencing alignment files. Write resulting table to output directory. Columns are samples (cells) and rows are gene IDs. The sequence alignment files must be generated using FASTQ files generated by the \code{demultiplex} function in scruff package.
#' 
#' @param alignmentFFilePaths A character vector of the paths to input alignment files. They can be in SAM or BAM format.
#' @param reference Can be in one of the following 2 formats:
#' \itemize{
#'  \item{"Path to the reference GTF file."}{The TxDb obeject of the GTF file will be generated and saved in the same directory as the GTF file with ".sqlite" suffix.}
#'  \item{"A TxDb object."}{A TxDb object contains feature information about the reference genome. For more detail, please refer to \code{GenomicFeatures} package.}}
#' @param format Format of input sequence alignment files. \strong{"BAM"} or \strong{"SAM"}. Default is \strong{"BAM"}.
#' @param outDir Output directory for UMI counting results. Expression table will be stored in this directory. Default is \code{"./Count"}.
#' @param cores Number of cores used for parallelization. Default is \code{max(1, parallel::detectCores() / 2)}.
#' @param outputPrefix Prefix for expression table filename. Default is \code{"countUMI"}.
#' @param verbose Print log messages. Useful for debugging. Default to \strong{FALSE}.
#' @param logfile.prefix Prefix for log file. Default is current date and time in the format of \code{format(Sys.time(), "\%Y\%m\%d_\%H\%M\%S")}.
#' @return A expression matrix \code{data.table} object containing the raw counts of unique \emph{UMI:gene} pairs.
#' @import data.table foreach
#' @export
countUmi <- function(alignmentFilePaths,
                     reference,
                     format = "BAM",
                     outDir = "./Count",
                     cores = max(1, parallel::detectCores() / 2),
                     outputPrefix = "countUMI",
                     verbose = FALSE,
                     logfile.prefix = format(Sys.time(), "%Y%m%d_%H%M%S")) {
  
  message(paste(Sys.time(), "Start UMI counting ..."))
  
  logfile <- paste0(logfile.prefix, "_countUMI_log.txt")
  
  if (verbose) {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = logfile,
                 append = FALSE)
    .logMessages(Sys.time(),
                 alignmentFilePaths,
                 logfile = logfile, 
                 append = TRUE)
    message("... Input alignment files:")
    print(alignmentFilePaths)
  } else {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = NULL,
                 append = FALSE)
  }
  
  message(paste(Sys.time(),
                "... Creating output directory",
                outDir))
  dir.create(file.path(outDir),
             showWarnings = FALSE,
             recursive = TRUE)
  
  message(paste(Sys.time(),
                paste("... Loading TxDb file")))
  features <- suppressPackageStartupMessages(.gtfReadDb(reference, logfile))
  
  # parallelization
  cl <- if (verbose)
    parallel::makeCluster(cores, outfile = logfile)
  else
    parallel::makeCluster(cores)
  doParallel::registerDoParallel(cl)
  
  if (format == "SAM") {
    alignmentFilePaths <- foreach::foreach(
      i = alignmentFilePaths,
      .verbose = verbose,
      .combine = c,
      .multicombine = TRUE
    ) %dopar% {
      .toBam(i, logfile, overwrite = FALSE, index = FALSE)
    }
  }
  
  expr <- foreach::foreach(
    i = alignmentFilePaths,
    .verbose = verbose,
    .combine = cbind,
    .multicombine = TRUE,
    .packages = c("BiocGenerics", "S4Vectors",
                  "GenomicFeatures", "GenomicAlignments")
  ) %dopar% {
    suppressPackageStartupMessages(
      .countUmiUnit(i, features, format, logfile, verbose))
  }
  
  parallel::stopCluster(cl)
  
  expr <- data.table::data.table(expr, keep.rownames = TRUE)
  colnames(expr)[1] <- "geneid"
  
  message(paste(Sys.time(), paste(
    "... Write expression table to",
    file.path(outDir, paste0(
      format(Sys.time(),
             "%Y%m%d_%H%M%S"), "_",
      outputPrefix, ".tab"
    ))
  )))
  
  data.table::fwrite(expr, file.path(outDir, paste0(
    format(Sys.time(), "%Y%m%d_%H%M%S"), "_",
    outputPrefix, ".tab"
  )), sep = "\t")
  
  message(paste(Sys.time(), "... UMI counting done!"))
  return(expr)
}


.countUmiUnit <- function(i, features, format, logfile, verbose) {
  if (verbose) {
    .logMessages(Sys.time(),
                 "... UMI counting sample",
                 i,
                 logfile = logfile,
                 append = TRUE)
  }
  
  # if sequence alignment file is empty
  if (file.size(i) == 0) {
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    
    return (data.frame(countUmiDt,
                       row.names = 1,
                       check.names = FALSE,
                       fix.empty.names = FALSE))
  }
  
  bfl <- Rsamtools::BamFile(i)
  bamGA <- GenomicAlignments::readGAlignments(bfl, use.names = T)
  
  genomeReads <- data.table::data.table(
    name = names(bamGA),
    seqnames = as.vector(GenomicAlignments::seqnames(bamGA)))
  
  if (length(unique(genomeReads[, name])) != nrow(genomeReads)) {
    stop(paste0("Corrupt BAM file ",
                i,
                ". Duplicate read names detected.",
                " Try rerunning demultiplexing and alignment functions",
                " with appropriate number of cores."))
  }
  
  # reads mapped to genome (exclude ERCC spike-in)
  readsMappedToGenome <- nrow(
    genomeReads[!grepl("ERCC", genomeReads[, seqnames]), .(name)])
  
  # UMI filtering
  ol <- GenomicAlignments::findOverlaps(features, bamGA)
  
  ol.dt <- data.table::data.table(
    gene.id = base::names(features)[S4Vectors::queryHits(ol)],
    name = base::names(bamGA)[S4Vectors::subjectHits(ol)],
    pos = BiocGenerics::start(bamGA)[S4Vectors::subjectHits(ol)]
  )
  
  # if 0 read in the cell
  if (nrow(ol.dt) == 0) {
    readsMappedToGenes <- 0
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
    
  } else {
    
    ol.dt[, umi := data.table::last(data.table::tstrsplit(name, ":"))]
    
    # remove ambiguous gene alignments (union mode filtering)
    ol.dt <- ol.dt[!(
      base::duplicated(ol.dt, by = "name") |
        base::duplicated(ol.dt, by = "name", fromLast = TRUE)
    ), ]
    
    # reads mapped to genes
    readsMappedToGenes <- nrow(ol.dt[!grepl("ERCC", ol.dt[, gene.id ]), ])
    
    # UMI filtering
    
    # strict way of doing UMI correction:
    # reads with different pos are considered unique trancsript molecules
    # countUmi <- base::table(unique(ol.dt[, .(gene.id, umi, pos)])[, gene.id])
    
    # The way CEL-Seq pipeline does UMI filtering:
    # Reads with different UMI tags are 
    # considered unique trancsript molecules
    # Read positions do not matter
    countUmi <- base::table(unique(ol.dt[, .(gene.id, umi)])[, gene.id])
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    countUmiDt[gene.id %in% names(countUmi),
               eval(cell) := as.numeric(countUmi[gene.id])]
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
  }
  return (countUmiDt)
}
