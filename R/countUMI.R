#' Count the number of UMIs for each gene and output expression matrix
#' 
#' Count unique \emph{UMI:gene} pairs for single cell RNA-sequencing alignment files. Write resulting count matrix to output directory. Columns are samples (cells) and rows are gene IDs. The input sequence alignment files must be generated using FASTQ files generated by the \code{demultiplex} function in scruff package.
#' 
#' @param sce A \code{SingleCellExperiment} object of which the \code{colData} slot contains the \strong{alignment_path} column with paths to input cell-specific sequence alignment files (BAM or SAM format).
#' @param reference Path to the reference GTF file. The TxDb object of the GTF file will be generated and saved in the current working directory with ".sqlite" suffix.
#' @param format Format of input sequence alignment files. \strong{"BAM"} or \strong{"SAM"}. Default is \strong{"BAM"}.
#' @param outDir Output directory for UMI counting results. UMI corrected count matrix will be stored in this directory. Default is \code{"./Count"}.
#' @param cores Number of cores used for parallelization. Default is \code{max(1, parallel::detectCores() / 2)}.
#' @param outputPrefix Prefix for expression table filename. Default is \code{"countUMI"}.
#' @param verbose Print log messages. Useful for debugging. Default to \strong{FALSE}.
#' @param logfilePrefix Prefix for log file. Default is current date and time in the format of \code{format(Sys.time(), "\%Y\%m\%d_\%H\%M\%S")}.
#' @return A expression matrix \code{data.table} object containing the raw counts of unique \emph{UMI:gene} pairs.
#' @import data.table foreach
#' @export
countUMI <- function(sce,
                     reference,
                     format = "BAM",
                     outDir = "./Count",
                     cores = max(1, parallel::detectCores() / 2),
                     outputPrefix = "countUMI",
                     verbose = FALSE,
                     logfilePrefix = format(Sys.time(), "%Y%m%d_%H%M%S")) {
  
  message(paste(Sys.time(), "Start UMI counting ..."))
  print(match.call(expand.dots = TRUE))
  
  alignmentFilePaths <- SummarizedExperiment::colData(sce)$alignment_path
  
  logfile <- paste0(logfilePrefix, "_countUMI_log.txt")
  
  if (verbose) {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = logfile,
                 append = FALSE)
    .logMessages(Sys.time(),
                 alignmentFilePaths,
                 logfile = logfile, 
                 append = TRUE)
    message("... Input alignment files:")
    print(alignmentFilePaths)
  } else {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = NULL,
                 append = FALSE)
  }
  
  message(paste(Sys.time(),
                "... Creating output directory",
                outDir))
  dir.create(file.path(outDir),
             showWarnings = FALSE,
             recursive = TRUE)
  
  message(paste(Sys.time(),
                paste("... Loading TxDb file")))
  features <- suppressPackageStartupMessages(.gtfReadDb(reference, logfile))
  
  # parallelization
  cl <- if (verbose)
    parallel::makeCluster(cores, outfile = logfile)
  else
    parallel::makeCluster(cores)
  doParallel::registerDoParallel(cl)
  
  if (format == "SAM") {
    alignmentFilePaths <- foreach::foreach(
      i = alignmentFilePaths,
      .verbose = verbose,
      .combine = c,
      .multicombine = TRUE
    ) %dopar% {
      .toBam(i, logfile, overwrite = FALSE, index = FALSE)
    }
  }
  
  expr <- foreach::foreach(
    i = alignmentFilePaths,
    .verbose = verbose,
    .combine = cbind,
    .multicombine = TRUE,
    .packages = c("BiocGenerics", "S4Vectors",
                  "GenomicFeatures", "GenomicAlignments")
  ) %dopar% {
    suppressPackageStartupMessages(
      .countUmiUnit(i, features, format, logfile, verbose))
  }
  
  parallel::stopCluster(cl)
  
  expr <- data.table::data.table(expr, keep.rownames = TRUE)
  colnames(expr)[1] <- "geneid"
  
  message(paste(Sys.time(), paste(
    "... Write UMI filtered count matrix to",
    file.path(outDir, paste0(
      format(Sys.time(),
             "%Y%m%d_%H%M%S"), "_",
      outputPrefix, ".tab"
    ))
  )))
  
  data.table::fwrite(expr, file.path(outDir, paste0(
    format(Sys.time(), "%Y%m%d_%H%M%S"), "_",
    outputPrefix, ".tab"
  )), sep = "\t")
  
  message(paste(Sys.time(),
                "... Add count matrix and QC metrics to SCE object."))
  
  newsce <- SingleCellExperiment::SingleCellExperiment(
    assays = list(counts = S4Vectors::DataFrame(
      expr[!geneid %in% c("reads_mapped_to_genome",
                          "reads_mapped_to_genes"), -"geneid"],
      row.names = expr[!geneid %in% c("reads_mapped_to_genome",
                                      "reads_mapped_to_genes"), geneid])))
  
  readmapping <- t(expr[geneid %in% c("reads_mapped_to_genome",
                                      "reads_mapped_to_genes"), -"geneid"])
  colnames(readmapping) <- c("reads_mapped_to_genome",
                             "reads_mapped_to_genes")
  
  SummarizedExperiment::colData(newsce) <- 
    cbind(SummarizedExperiment::colData(sce), readmapping)
  
  SingleCellExperiment::isSpike(newsce, "ERCC") <- grepl("^ERCC-",
                                                         rownames(newsce))
  
  # get gene annotations
  gtfEG = refGenome::ensemblGenome()
  refGenome::read.gtf(gtfEG, filename = gtf)
  geneAnnotation <- data.table::data.table(
    unique(refGenome::getGtf(gtfEG)[, c("gene_id",
                                        "gene_name",
                                        "gene_biotype",
                                        "seqid",
                                        "strand")]))
  
  SummarizedExperiment::rowData(newsce) <-
    S4Vectors::DataFrame(geneAnnotation[, -"gene_id"],
                         row.names = geneAnnotation[, gene_id])
  
  # UMI filtered transcripts QC metrics
  # total counts
  totalCounts <- base::colSums(as.data.frame(
    SummarizedExperiment::assay(newsce)[!SingleCellExperiment::isSpike(newsce, "ERCC"), ]))
  
  # MT counts
  mtCounts <- base::colSums(as.data.frame(
    SummarizedExperiment::assay(newsce)[grep("^mt-", rowData(newsce)[, "gene_name"]), ]))
  
  # gene number
  # protein coding genes
  # protein coding counts
  
  
  message(paste(Sys.time(), "... UMI counting done!"))
  return(newsce)
}


.countUmiUnit <- function(i, features, format, logfile, verbose) {
  if (verbose) {
    .logMessages(Sys.time(),
                 "... UMI counting sample",
                 i,
                 logfile = logfile,
                 append = TRUE)
  }
  
  # if sequence alignment file is empty
  if (file.size(i) == 0) {
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    
    return (data.frame(countUmiDt,
                       row.names = 1,
                       check.names = FALSE,
                       fix.empty.names = FALSE))
  }
  
  bfl <- Rsamtools::BamFile(i)
  bamGA <- GenomicAlignments::readGAlignments(bfl, use.names = T)
  
  genomeReads <- data.table::data.table(
    name = names(bamGA),
    seqnames = as.vector(GenomicAlignments::seqnames(bamGA)))
  
  if (length(unique(genomeReads[, name])) != nrow(genomeReads)) {
    stop(paste0("Corrupt BAM file ",
                i,
                ". Duplicate read names detected.",
                " Try rerunning demultiplexing and alignment functions",
                " with appropriate number of cores."))
  }
  
  # reads mapped to genome (exclude ERCC spike-in)
  readsMappedToGenome <- nrow(
    genomeReads[!grepl("ERCC", genomeReads[, seqnames]), .(name)])
  
  # UMI filtering
  ol <- GenomicAlignments::findOverlaps(features, bamGA)
  
  ol.dt <- data.table::data.table(
    gene.id = base::names(features)[S4Vectors::queryHits(ol)],
    name = base::names(bamGA)[S4Vectors::subjectHits(ol)],
    pos = BiocGenerics::start(bamGA)[S4Vectors::subjectHits(ol)]
  )
  
  # if 0 read in the cell
  if (nrow(ol.dt) == 0) {
    readsMappedToGenes <- 0
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
    
  } else {
    
    ol.dt[, umi := data.table::last(data.table::tstrsplit(name, ":"))]
    
    # remove ambiguous gene alignments (union mode filtering)
    ol.dt <- ol.dt[!(
      base::duplicated(ol.dt, by = "name") |
        base::duplicated(ol.dt, by = "name", fromLast = TRUE)
    ), ]
    
    # reads mapped to genes
    readsMappedToGenes <- nrow(ol.dt[!grepl("ERCC", ol.dt[, gene.id ]), ])
    
    # UMI filtering
    
    # strict way of doing UMI correction:
    # reads with different pos are considered unique trancsript molecules
    # countUmi <- base::table(unique(ol.dt[, .(gene.id, umi, pos)])[, gene.id])
    
    # The way CEL-Seq pipeline does UMI filtering:
    # Reads with different UMI tags are 
    # considered unique trancsript molecules
    # Read positions do not matter
    countUmi <- base::table(unique(ol.dt[, .(gene.id, umi)])[, gene.id])
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    countUmiDt[gene.id %in% names(countUmi),
               eval(cell) := as.numeric(countUmi[gene.id])]
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
  }
  return (countUmiDt)
}
