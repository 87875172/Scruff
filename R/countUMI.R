#' Count the number of UMIs for each gene and output count matrix
#' 
#' Count unique \emph{UMI:gene} pairs for single cell RNA-sequencing alignment files. Write resulting count matrix to output directory. Columns are samples (cells) and rows are gene IDs. The input sequence alignment files must be generated using FASTQ files generated by the \code{demultiplex} function in scruff package. Return a SingleCellExperiment object containing the count matrix, cell and gene annotations, and all QC metrics.
#' 
#' @param sce A \code{SingleCellExperiment} object of which the \code{colData} slot contains the \strong{alignment_path} column with paths to input cell-specific sequence alignment files (BAM or SAM format).
#' @param reference Path to the reference GTF file. The TxDb object of the GTF file will be generated and saved in the current working directory with ".sqlite" suffix.
#' @param format Format of input sequence alignment files. \strong{"BAM"} or \strong{"SAM"}. Default is \strong{"BAM"}.
#' @param outDir Output directory for UMI counting results. UMI corrected count matrix will be stored in this directory. Default is \code{"./Count"}.
#' @param cellPerWell Number of cells per well. Can be an integer (e.g. 1) indicating the number of cells in each well or an vector with length equal to the total number of cells in the input alignment files specifying the number of cells in each file. Default is 1.
#' @param cores Number of cores used for parallelization. Default is \code{max(1, parallel::detectCores() / 2)}, i.e. the number of available cores divided by 2.
#' @param outputPrefix Prefix for expression table filename. Default is \code{"countUMI"}.
#' @param verbose Print log messages. Useful for debugging. Default to \strong{FALSE}.
#' @param logfilePrefix Prefix for log file. Default is current date and time in the format of \code{format(Sys.time(), "\%Y\%m\%d_\%H\%M\%S")}.
#' @return A \strong{SingleCellExperiment} object.
#' @import data.table foreach
#' @export
countUMI <- function(sce,
                     reference,
                     format = "BAM",
                     outDir = "./Count",
                     cellPerWell = 1,
                     cores = max(1, parallel::detectCores() / 2),
                     outputPrefix = "countUMI",
                     verbose = FALSE,
                     logfilePrefix = format(Sys.time(), "%Y%m%d_%H%M%S")) {
  
  message(paste(Sys.time(), "Start UMI counting ..."))
  print(match.call(expand.dots = TRUE))
  
  if (ncol(sce) != length(cellPerWell) & length(cellPerWell) != 1) {
    stop(paste0("cellPerWell doe not have same length as ncol(" , sce, ")."))
  }
  
  alignmentFilePaths <- SummarizedExperiment::colData(sce)$alignment_path
  
  logfile <- paste0(logfilePrefix, "_countUMI_log.txt")
  
  if (verbose) {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = logfile,
                 append = FALSE)
    .logMessages(Sys.time(),
                 alignmentFilePaths,
                 logfile = logfile, 
                 append = TRUE)
    message("... Input alignment files:")
    print(alignmentFilePaths)
  } else {
    .logMessages(Sys.time(),
                 "... Start UMI counting",
                 logfile = NULL,
                 append = FALSE)
  }
  
  message(paste(Sys.time(),
                "... Creating output directory",
                outDir))
  dir.create(file.path(outDir),
             showWarnings = FALSE,
             recursive = TRUE)
  
  message(paste(Sys.time(),
                paste("... Loading TxDb file")))
  features <- suppressPackageStartupMessages(.gtfReadDb(reference, logfile))
  
  # parallelization
  cl <- if (verbose)
    parallel::makeCluster(cores, outfile = logfile)
  else
    parallel::makeCluster(cores)
  doParallel::registerDoParallel(cl)
  
  if (format == "SAM") {
    alignmentFilePaths <- foreach::foreach(
      i = alignmentFilePaths,
      .verbose = verbose,
      .combine = c,
      .multicombine = TRUE
    ) %dopar% {
      .toBam(i, logfile, overwrite = FALSE, index = FALSE)
    }
  }
  
  expr <- foreach::foreach(
    i = alignmentFilePaths,
    .verbose = verbose,
    .combine = cbind,
    .multicombine = TRUE,
    .packages = c("BiocGenerics", "S4Vectors",
                  "GenomicFeatures", "GenomicAlignments")
  ) %dopar% {
    suppressPackageStartupMessages(
      .countUmiUnit(i, features, format, logfile, verbose))
  }
  
  parallel::stopCluster(cl)
  
  expr <- data.table::data.table(expr, keep.rownames = TRUE)
  colnames(expr)[1] <- "geneid"
  
  message(paste(Sys.time(), paste(
    "... Write UMI filtered count matrix to",
    file.path(outDir, paste0(
      format(Sys.time(),
             "%Y%m%d_%H%M%S"), "_",
      outputPrefix, ".tab"
    ))
  )))
  
  data.table::fwrite(expr, file.path(outDir, paste0(
    format(Sys.time(), "%Y%m%d_%H%M%S"), "_",
    outputPrefix, ".tab"
  )), sep = "\t")
  
  message(paste(Sys.time(),
                "... Add count matrix and QC metrics to SCE object."))
  
  newsce <- SingleCellExperiment::SingleCellExperiment(
    assays = list(counts = S4Vectors::DataFrame(
      expr[!geneid %in% c("reads_mapped_to_genome",
                          "reads_mapped_to_genes"), -"geneid"],
      row.names = expr[!geneid %in% c("reads_mapped_to_genome",
                                      "reads_mapped_to_genes"), geneid])))
  
  readmapping <- t(expr[geneid %in% c("reads_mapped_to_genome",
                                      "reads_mapped_to_genes"), -"geneid"])
  colnames(readmapping) <- c("reads_mapped_to_genome",
                             "reads_mapped_to_genes")
  
  SingleCellExperiment::isSpike(newsce, "ERCC") <- grepl("^ERCC-",
                                                         rownames(newsce))
  
  # get gene annotations
  gtfEG = refGenome::ensemblGenome()
  refGenome::read.gtf(gtfEG, filename = gtf)
  geneAnnotation <- data.table::data.table(
    unique(refGenome::getGtf(gtfEG)[, c("gene_id",
                                        "gene_name",
                                        "gene_biotype",
                                        "seqid")]))
  
  SummarizedExperiment::rowData(newsce) <-
    S4Vectors::DataFrame(geneAnnotation[, -"gene_id"],
                         row.names = geneAnnotation[, gene_id])
  
  # UMI filtered transcripts QC metrics
  # total counts exclude ERCC
  totalCounts <- base::colSums(as.data.frame(
    SummarizedExperiment::assay(newsce)[!SingleCellExperiment::isSpike(newsce, "ERCC"), ]))
  
  # MT counts
  mtCounts <- base::colSums(as.data.frame(
    SummarizedExperiment::assay(newsce)
    [grep("^mt-", SummarizedExperiment::rowData(newsce)[, "gene_name"]), ]))
  
  # gene number exclude ERCC
  cm <- SummarizedExperiment::assay(newsce)[
    !SingleCellExperiment::isSpike(newsce, "ERCC"), ]
  
  geneNumber <- vapply(colnames(cm), function(cells) {
    sum(cm[, cells] != 0)
  }, integer(1))
  
  # protein coding genes
  proteinCodingGene <- geneAnnotation[gene_biotype == "protein_coding",
                                      gene_id]
  proGene <- vapply(colnames(cm), function(cells) {
    sum(cm[proteinCodingGene, cells] != 0)
  }, integer(1))
  
  # protein coding counts
  proCounts <- base::colSums(as.data.frame(cm[proteinCodingGene, ]))
  
  # number of cells per well, default = 1
  
  SummarizedExperiment::colData(newsce) <- 
    cbind(SummarizedExperiment::colData(sce),
          readmapping,
          total_counts = totalCounts,
          mt_counts = mtCounts,
          genes = geneNumber,
          protein_coding_genes = proGene,
          protein_coding_counts = proCounts,
          number_of_cells = cellPerWell)
  
  message(paste(Sys.time(), "... UMI counting done!"))
  return(newsce)
}


.countUmiUnit <- function(i, features, format, logfile, verbose) {
  if (verbose) {
    .logMessages(Sys.time(),
                 "... UMI counting sample",
                 i,
                 logfile = logfile,
                 append = TRUE)
  }
  
  # if sequence alignment file is empty
  if (file.size(i) == 0) {
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    
    return (data.frame(countUmiDt,
                       row.names = 1,
                       check.names = FALSE,
                       fix.empty.names = FALSE))
  }
  
  bfl <- Rsamtools::BamFile(i)
  bamGA <- GenomicAlignments::readGAlignments(bfl, use.names = T)
  
  genomeReads <- data.table::data.table(
    name = names(bamGA),
    seqnames = as.vector(GenomicAlignments::seqnames(bamGA)))
  
  if (length(unique(genomeReads[, name])) != nrow(genomeReads)) {
    stop(paste0("Corrupt BAM file ",
                i,
                ". Duplicate read names detected.",
                " Try rerunning demultiplexing and alignment functions",
                " with appropriate number of cores."))
  }
  
  # reads mapped to genome (exclude ERCC spike-in)
  readsMappedToGenome <- nrow(
    genomeReads[!grepl("ERCC", genomeReads[, seqnames]), .(name)])
  
  # UMI filtering
  ol <- GenomicAlignments::findOverlaps(features, bamGA)
  
  ol.dt <- data.table::data.table(
    gene.id = base::names(features)[S4Vectors::queryHits(ol)],
    name = base::names(bamGA)[S4Vectors::subjectHits(ol)],
    pos = BiocGenerics::start(bamGA)[S4Vectors::subjectHits(ol)]
  )
  
  # if 0 read in the cell
  if (nrow(ol.dt) == 0) {
    readsMappedToGenes <- 0
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
    
  } else {
    
    ol.dt[, umi := data.table::last(data.table::tstrsplit(name, ":"))]
    
    # remove ambiguous gene alignments (union mode filtering)
    ol.dt <- ol.dt[!(
      base::duplicated(ol.dt, by = "name") |
        base::duplicated(ol.dt, by = "name", fromLast = TRUE)
    ), ]
    
    # reads mapped to genes
    readsMappedToGenes <- nrow(ol.dt[!grepl("ERCC", ol.dt[, gene.id ]), ])
    
    # UMI filtering
    
    # strict way of doing UMI correction:
    # reads with different pos are considered unique trancsript molecules
    # countUmi <- base::table(unique(ol.dt[, .(gene.id, umi, pos)])[, gene.id])
    
    # The way CEL-Seq pipeline does UMI filtering:
    # Reads with different UMI tags are 
    # considered unique trancsript molecules
    # Read positions do not matter
    countUmi <- base::table(unique(ol.dt[, .(gene.id, umi)])[, gene.id])
    
    # clean up
    countUmiDt <- data.table::data.table(gene.id = c(names(features),
                                                     "reads_mapped_to_genome",
                                                     "reads_mapped_to_genes"))
    cell <- .removeLastExtension(i)
    countUmiDt[[cell]] <- 0
    countUmiDt[gene.id == "reads_mapped_to_genome",
               cell] <- readsMappedToGenome
    countUmiDt[gene.id == "reads_mapped_to_genes",
               cell] <- readsMappedToGenes
    countUmiDt[gene.id %in% names(countUmi),
               eval(cell) := as.numeric(countUmi[gene.id])]
    
    # coerce to data frame to keep rownames for cbind combination
    countUmiDt <- data.frame(countUmiDt,
                             row.names = 1,
                             check.names = FALSE,
                             fix.empty.names = FALSE)
  }
  return (countUmiDt)
}
